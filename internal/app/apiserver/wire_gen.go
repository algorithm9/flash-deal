// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package apiserver

import (
	"github.com/algorithm9/flash-deal/internal/config"
	"github.com/algorithm9/flash-deal/internal/module/product/delivery/http"
	repository2 "github.com/algorithm9/flash-deal/internal/module/product/repository"
	service2 "github.com/algorithm9/flash-deal/internal/module/product/service"
	"github.com/algorithm9/flash-deal/internal/module/seckill/delivery/http"
	repository3 "github.com/algorithm9/flash-deal/internal/module/seckill/repository"
	service3 "github.com/algorithm9/flash-deal/internal/module/seckill/service"
	"github.com/algorithm9/flash-deal/internal/module/user/delivery/http"
	"github.com/algorithm9/flash-deal/internal/module/user/repository"
	"github.com/algorithm9/flash-deal/internal/module/user/service"
	"github.com/algorithm9/flash-deal/internal/shared/entx"
	"github.com/algorithm9/flash-deal/internal/shared/idgen"
	"github.com/algorithm9/flash-deal/internal/shared/middleware"
	"github.com/algorithm9/flash-deal/internal/shared/redisclient"
	"github.com/algorithm9/flash-deal/pkg/cache"
)

// Injectors from wire.go:

func InitServer(cfgPath string) (*Server, func(), error) {
	configConfig := config.LoadConfig(cfgPath)
	serverConfig := config.ProvideServer(configConfig)
	logConfig := config.ProvideLog(configConfig)
	options := NewOptions(serverConfig, logConfig)
	databaseConfig := config.ProvideDB(configConfig)
	client, cleanup, err := entx.NewEntClient(databaseConfig)
	if err != nil {
		return nil, nil, err
	}
	machine := config.ProvideMachine(configConfig)
	snowflakeIDGen, err := idgen.NewSnowflakeIDGen(machine)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	userRepository := repository.NewUserRepo(client, snowflakeIDGen)
	captcha := service.NewCaptcha()
	redisConfig := config.ProvideRedis(configConfig)
	redisclientClient, cleanup2 := redisclient.NewClient(redisConfig)
	authService := service.NewAuthService(userRepository, captcha, redisclientClient)
	authHandler := userhttp.NewAuthHandler(authService)
	userRouter := userhttp.NewUserRouter(authHandler)
	goodsRepository := repository2.NewGoodsRepo(client)
	goodsService := service2.NewGoodsService(goodsRepository, redisclientClient)
	goodsHandler := producthttp.NewGoodsHandler(goodsService)
	goodsRouter := producthttp.NewGoodsRouter(goodsHandler)
	luaRepo := repository3.NewLuaRepo(redisclientClient)
	seckillRepository := repository3.NewSeckillRepository(client)
	kafka := config.ProvideKafka(configConfig)
	queueProducer, cleanup3, err := repository3.NewKafkaProducer(kafka)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	modelCache := config.ProvideCache(configConfig)
	cacheCache := cache.NewCache(modelCache)
	repositoryCache := repository3.NewCache(cacheCache, redisclientClient)
	serviceService := service3.New(luaRepo, seckillRepository, queueProducer, repositoryCache)
	seckillHandler := seckillhttp.NewSeckillHandler(serviceService)
	seckillRouter := seckillhttp.NewSeckillRouter(seckillHandler)
	jwt := config.ProvideJWT(configConfig)
	authJWT, err := middleware.NewAuthJWTMiddleware(jwt, userRepository)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	engine := NewGinEngine(serverConfig, userRouter, goodsRouter, seckillRouter, authJWT)
	server := New(options, engine)
	return server, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}
